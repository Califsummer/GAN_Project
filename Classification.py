#The code in this file is used to do classification on real-world data with a LSTM model that is trained by data generated by GAN

import tensorflow as tf
import pandas as pd
import numpy as np
import keras.backend as K
from tensorflow.keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
import keras
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split
from keras.callbacks import EarlyStopping, ModelCheckpoint

#Reshape data to fit input dimension
def data_reshape(dst, label, timesteps):
    '''feature_mean = []
    feature_std = []
    for i in label:
            mean = dst[i].mean()
            std = dst[i].std()
            feature_mean.append(mean)
            feature_std.append(std)
            dst[i] = (dst[i] - mean) / std'''
    #reshape
    input = dst[label]
    Y = dst['isAttack']
    input = np.array(input)
    Y = np.array(Y)
    Y = to_categorical(Y)
    drop = input.shape[0] % timesteps
    for i in range(drop):
        input = np.delete(input, input.shape[0] - i - 1, axis=0)
        Y = np.delete(Y, Y.shape[0] - i - 1, axis=0)
    X = input.reshape((input.shape[0] // timesteps, timesteps, input.shape[1]))      
    #print(Y.shape)
    y = Y.reshape(Y.shape[0] // timesteps ,timesteps, 2)  #8 kinds of attack in dataset
    return X, y

#For evaluation on the performance of classification
def classreport(y_true, y_pred):
    # Count positive samples.
    c1 = np.sum(np.round(np.clip(y_true * y_pred, 0, 1)))
    c2 = np.sum(np.round(np.clip(y_pred, 0, 1)))
    c3 = np.sum(np.round(np.clip(y_true, 0, 1)))
    
    print(c1)
    print(c2)
    print(c3)
    # If there are no true samples, fix the F1 score at 0.
    if c3 == 0:
        return 0
    # How many selected items are relevant?
    precision = c1 / c2
    # How many relevant items are selected?
    recall = c1 / c3
    # Calculate f1_score
    f1_score = 2 * (precision * recall) / (precision + recall)
    return precision,recall,f1_score

#Read data generated by GAN (for training the model), generated data is used for data augumentation by enlarging dataset
data = pd.read_csv('D:\SCADA_Data\GeneratedData')
timestep = 80
X_Label = [i for i in data.columns.tolist() if i not in 'isAttack']
X, y = data_reshape(data, X_Label, timestep)    
X = np.asarray(X).astype('float32')
    
#Read real-world data (for doing classification and evaluating performance)
data_Real = pd.read_csv('D:\SCADA_Data\ProcessedRealData')
timestep = 80
X_Label_Real = [i for i in data_Real.columns.tolist() if i not in 'isAttack']
X_Real, y_Real = data_reshape(data_Real, X_Label_Real, timestep)
X_Real = np.asarray(X_Real).astype('float32')


#Classification model
def RNN_model(X, y):
    #data['DestIP'] = data['DestIP'].replace({'10.0.0.3':1, '10.0.0.4':1000, '10.0.0.5':20000, '10.0.0.111':5884431})
    #data['Protocol'] = data['Protocol'].replace({'TCP':10, 'Modbus/TCP':1000})
    #data['Fin'] = data['Fin'].replace({'NotSet':0, 'Set':1})
    #data['Reset'] = data['Reset'].replace({'NotSet':0, 'Set':1})    
    
    precision = []
    recall = []
    f1 = []
    for kfold in range(1):
        model = Sequential()
        model.add(LSTM(256,return_sequences=True,input_shape=(X.shape[1],X.shape[2])))
        model.add(LSTM(128,return_sequences=True))
        model.add(Dense(2, activation='softmax'))
        model.compile(loss='binary_crossentropy', optimizer='adam',metrics=['accuracy'])
        print(model.summary())
        #model.fit(X, y, epochs=150, batch_size=300)
        
        early_stopping =EarlyStopping(monitor='val_loss', patience=15)
        model_checkpoint = ModelCheckpoint(filepath = 'bst_model_path.h5', save_best_only=True, save_weights_only=True)

        #hist = 
        model.fit(X, y,
                validation_data=(X_Real, y_Real),
                 epochs=550, batch_size=256, shuffle=True,
                 callbacks=[early_stopping, model_checkpoint])

        model.load_weights('bst_model_path.h5')
        
    
    return model
  
model = RNN_model(X, y)

preds = model.predict(X_Real)

preds_prob = preds.reshape(preds.shape[0]*timestep,2)
pred_class = np.argmax(preds_prob, axis=1)

y_prob = y_Real.reshape(y_Real.shape[0]*timestep,2)
y_class = np.argmax(y_prob, axis=1)

res = tf.keras.metrics.BinaryAccuracy()
res.update_state(pred_class, y_class)
res.result().numpy()

pred_index = np.where(pred_class == 1)
real_index = np.where(data_Real['isAttack'] == 1) 
print(classreport(data['isAttack'],pred_class))
